using static FlutterSharp.UI.Lerp;
using static FlutterSharp.UI.UITypes;

namespace FlutterSharp.UI
{
    /// A radius for either circular or elliptical shapes.
    public class Radius
    {
        public Radius(double x, double y)
        {

        }

        /// Constructs a circular radius. [x] and [y] will have the same radius value.
        public static Radius Circular(double radius) => Radius.Elliptical(radius, radius);

        /// Constructs an elliptical radius with the given radii.
        public static Radius Elliptical(double x, double y) => new Radius(x, y);

        /// The radius value on the horizontal axis.
        public readonly double X;

        /// The radius value on the vertical axis.
        public readonly double Y;

        /// A radius with [x] and [y] values set to zero.
        ///
        /// You can use [Radius.zero] with [RRect] to have right-angle corners.
        public static readonly Radius Zero = Radius.Circular(0.0);

        /// Unary negation operator.
        ///
        /// Returns a Radius with the distances negated.
        ///
        /// Radiuses with negative values aren't geometrically meaningful, but could
        /// occur as part of expressions. For example, negating a radius of one pixel
        /// and then adding the result to another radius is equivalent to subtracting
        /// a radius of one pixel from the other.
        public static Radius operator -(Radius radius) => Radius.Elliptical(-radius.X, -radius.Y);

        /// Binary subtraction operator.
        ///
        /// Returns a radius whose [x] value is the left-hand-side operand's [x]
        /// minus the right-hand-side operand's [x] and whose [y] value is the
        /// left-hand-side operand's [y] minus the right-hand-side operand's [y].
        public static Radius operator -(Radius radius, Radius other) => Radius.Elliptical(radius.X - other.X, radius.Y - other.Y);

        /// Binary addition operator.
        ///
        /// Returns a radius whose [x] value is the sum of the [x] values of the
        /// two operands, and whose [y] value is the sum of the [y] values of the
        /// two operands.
        public static Radius operator +(Radius radius, Radius other) => Radius.Elliptical(radius.X + other.X, radius.Y + other.Y);

        /// Multiplication operator.
        ///
        /// Returns a radius whose coordinates are the coordinates of the
        /// left-hand-side operand (a radius) multiplied by the scalar
        /// right-hand-side operand (a double).
        public static Radius operator *(Radius radius, Radius other) => Radius.Elliptical(radius.X * other.X, radius.Y * other.Y);

        /// Division operator.
        ///
        /// Returns a radius whose coordinates are the coordinates of the
        /// left-hand-side operand (a radius) divided by the scalar right-hand-side
        /// operand (a double).
        public static Radius operator /(Radius radius, Radius other) => Radius.Elliptical(radius.X / other.X, radius.Y / other.Y);

        /*/// Integer (truncating) division operator. OPERATOR NOT AVAILABLE ON CSHARP
        ///
        /// Returns a radius whose coordinates are the coordinates of the
        /// left-hand-side operand (a radius) divided by the scalar right-hand-side
        /// operand (a double), rounded towards zero.
        //Radius operator ~/(double operand) => Radius.elliptical((x ~/ operand).toDouble(), (y ~/ operand).toDouble());*/

        /// Modulo (remainder) operator.
        ///
        /// Returns a radius whose coordinates are the remainder of dividing the
        /// coordinates of the left-hand-side operand (a radius) by the scalar
        /// right-hand-side operand (a double).
        public static Radius operator %(Radius radius, double operand) => Radius.Elliptical(radius.X % operand, radius.Y % operand);

        /// Linearly interpolate between two radii.
        ///
        /// If either is null, this function substitutes [Radius.zero] instead.
        ///
        /// The `t` argument represents position on the timeline, with 0.0 meaning
        /// that the interpolation has not started, returning `a` (or something
        /// equivalent to `a`), 1.0 meaning that the interpolation has finished,
        /// returning `b` (or something equivalent to `b`), and values in between
        /// meaning that the interpolation is at the relevant point on the timeline
        /// between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
        /// 1.0, so negative values and values greater than 1.0 are valid (and can
        /// easily be generated by curves such as [Curves.elasticInOut]).
        ///
        /// Values for `t` are usually obtained from an [Animation<double>], such as
        /// an [AnimationController].
        public static Radius Lerp(Radius a, Radius b, double t)
        {
            if (a == null && b == null)
                return null;
            if (a == null)
                return Radius.Elliptical(b.X * t, b.Y * t);
            if (b == null)
            {
                double k = 1.0 - t;
                return Radius.Elliptical(a.X * k, a.Y * k);
            }

            return Radius.Elliptical(
                LerpDouble(a.X, b.X, t),
                LerpDouble(a.Y, b.Y, t)
            );
        }

        public override bool Equals(object obj)
        {
            if (obj is Radius typedOther)
                return X == typedOther.X &&
                       Y == typedOther.Y;

            return false;
        }

        public override int GetHashCode()
        {
            return HashValues(X, Y);
        }

        public override string ToString()
        {
            return X == Y ? $"Radius.Circular({X.ToStringAsFixed(1)})" : $"Radius.Elliptical({X.ToStringAsFixed(1)}, {Y.ToStringAsFixed(1)})";
        }
    }
}
